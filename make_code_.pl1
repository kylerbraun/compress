make_code_: procedure(bytes, order, codes);

declare count_bytes_
     entry(dimension(*) bit(9)) returns(dimension(0:511) fixed binary(35));
declare length builtin;
declare sort_items_$fixed_bin entry(pointer);

declare bytes(*) bit(9);
declare codes(0:511) bit(20) varying;
declare code_value fixed binary(20);
declare count fixed binary(35) based(counts_sorted.vector(i));
declare counts(0:511) fixed binary(35);
declare next_count fixed binary(35) based(counts_sorted.vector(i + 1));
declare 01 counts_sorted aligned,
	   02 length fixed binary(18) initial(512),
	   02 vector(0:511) pointer unaligned;
declare i fixed binary(9);
declare j fixed binary(5);
declare order(0:511) fixed binary(9);
declare next_code bit(20) varying initial("0"b);
declare offset fixed binary(18);
declare total fixed binary(35) initial(0);

counts = count_bytes_(bytes);

do i = lbound(counts, 1) to hbound(counts, 1);
   counts_sorted.vector(i) = addr(counts(i));
end;

call sort_items_$fixed_bin(addr(counts_sorted));

do i = hbound(counts_sorted.vector, 1) to lbound(counts_sorted.vector, 1) by -1;
   offset = convert(offset, rel(addr(count)));
   order(511 - i) = offset - convert(offset, rel(addr(counts)));
end;

do i = lbound(counts, 1) to hbound(counts, 1);
   total = total + counts(i);
end;

do i = hbound(counts_sorted.vector, 1) to lbound(counts_sorted.vector, 1) by -1;
   if count = 0
      then goto fill_unused_codes;
   do j = length(next_code) repeat j + 1 while("1"b);
      if count*2**j >= total then do;
	 if j > length(next_code) then do;
	    /* if |count/total - 1/2**j| > |count/total - 1/2**(j - 1)| */
	    /* Since we don't want unnecessary divisions, we convert the above
	       expression into units of 1/(total*2**j) before comparing. */
	    if count*2**j - total > total*2 - count*2**j
	       then j = j - 1;
	 end;
	 goto allocate_code;
      end;
   end;
allocate_code:
   /* If there are more bytes to encode, make sure we leave some codes avaiable
      for them. */
   if j = length(next_code) & i < hbound(counts_sorted.vector, 1)
	& next_count > 0 & next_code = copy("1"b, j)
      then j = j + 1;

   next_code = next_code || copy("0"b, j - length(next_code));
   codes(order(511 - i)) = next_code;

   /* Increment the bit-string in next_code by 1 without increasing its length.
      Because of the check above, this will only overflow if there are no more
      bytes to encode, in which case we won't use next_code again. */
   code_value = convert(code_value, next_code);
   code_value = code_value + 1;
   next_code = substr(convert(next_code, code_value),
		      20 - length(next_code) + 1);
end;

fill_unused_codes:
do i = i to lbound(counts_sorted.vector, 1) by -1;
   codes(order(511 - i)) = ""b;
end;

end make_code_;
