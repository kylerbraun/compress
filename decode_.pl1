/* -*- indent-tabs-mode: nil -*- */
decode_: procedure(source_arg, source_bitcount, destination_arg, order, codes,
                   used)
           returns(fixed binary(20));

declare source_arg pointer;
declare source_bitcount fixed binary(24);
declare destination_arg pointer;
declare order(0:511) fixed binary(9);
declare codes(0:511) bit(20) varying;
declare used fixed binary(24);

declare 01 node based aligned,
           02 has_value bit,
           02 value character,
           02 children(0:1) pointer;

declare 01 table(0:511) based aligned,
           02 bytes character(9) varying,
           02 next_pointer pointer,
           02 subtree pointer initial((512) null),
           02 prefix_length fixed binary(5);

declare 01 entry like table based aligned;

declare byte bit(9);
declare child_index fixed binary(1);
declare cleanup condition;
declare code_pointer pointer;
declare copy_length fixed bin;
declare compress_bad_code condition;
declare destination pointer initial(destination_arg);
declare error condition;
declare i fixed binary(10);
declare input character(divide(source_bitcount + 8, 9, 20)) based(source);
declare j fixed binary(24);
declare left fixed binary(4);
declare max_prefix_length fixed binary(5) static initial(5) options(constant);
declare null builtin;
declare num_ptables fixed binary(21) static initial(63) options(constant);
declare old_written fixed binary(20);
declare output character(255*1024*4) based(destination);
declare partial_index fixed binary(24);
declare pentry pointer;
declare pnode pointer based(ppnode);
declare pnode_ro pointer;
declare ppnode pointer;
declare prefix_length fixed binary(5) initial(0);
declare ptable(num_ptables) pointer initial((num_ptables) null);
declare quit condition;
declare source pointer initial(source_arg);
declare subcode bit(20) varying;
declare table_index fixed binary(9);
declare tree pointer initial(null);
declare written fixed binary(20) initial(0);

if source_bitcount = used
   then return(written);

on cleanup begin;
   call free_tree(tree);
   call free_tables;
end;

do i = lbound(order, 1) to hbound(order, 1)
     while(length(codes(order(i))) > 0);
   subcode = codes(order(i));
   do ppnode = addr(tree) repeat addr(pnode->children(child_index))
        while(length(subcode) > 0);
      if pnode = null then do;
         allocate node set(pnode);
         pnode->has_value = "0"b;
         pnode->children = null;
      end;
      child_index = convert(child_index, substr(subcode, 1, 1));
      subcode = substr(subcode, 2);
   end;
   if pnode ^= null
      then signal error;
   allocate node set(pnode);
   pnode->has_value = "1"b;
   pnode->value = substr(collate9(), order(i) + 1, 1);
end;

pnode_ro = tree;
j = divide(used, 9, 24) + 1;
partial_index = length(input);
if mod(source_bitcount, 9) = 0
   then partial_index = partial_index + 1;
table_index = index(collate9(), substr(input, j, 1)) - 1;
byte = convert(byte, table_index);
call decode_bit_string(substr(byte, mod(used, 9) + 1));
code_pointer = get_next_pointer(byte);
do j = j + 1 to partial_index - 1;
  table_index = index(collate9(), substr(input, j, 1)) - 1;
  byte = convert(byte, table_index);
  if code_pointer ^= null then do;
     pentry = addr(code_pointer->table(table_index));
     if pentry->entry.subtree ^= null then do;
        copy_length = length(pentry->entry.bytes);
        substr(output, written + 1, copy_length) = pentry->entry.bytes;
        written = written + copy_length;
        prefix_length = pentry->entry.prefix_length;
        pnode_ro = pentry->entry.subtree;
        code_pointer = pentry->entry.next_pointer;
     end;
     else do;
        old_written = written;
        call decode_bit_string(byte);
        code_pointer = get_next_pointer(byte);
        copy_length = written - old_written;
        pentry->entry.bytes = substr(output, old_written + 1, copy_length);
        pentry->entry.prefix_length = prefix_length;
        pentry->entry.next_pointer = code_pointer;
        pentry->entry.subtree = pnode_ro;
     end;
  end;
  else do;
     call decode_bit_string(byte);
     code_pointer = get_next_pointer(byte);
  end;
end;
if mod(source_bitcount, 9) ^= 0 then do;
   table_index = index(collate9(), substr(input, partial_index, 1));
   byte = convert(byte, table_index);
   call decode_bit_string(substr(byte, 1, mod(source_bitcount, 9)));
end;
if prefix_length ^= 0 then do;
   used = source_bitcount - prefix_length;
   signal compress_bad_code;
end;

finish:
call free_tree(tree);
call free_tables;
return(written);

get_next_pointer: procedure(byte) returns(pointer);
   declare byte bit(9);
   declare next_index fixed binary(6);
   if left > max_prefix_length
      then return(null);
   next_index =
     convert(next_index, "1"b || substr(byte, 10 - left, left));
   if ptable(next_index) = null
      then allocate table set(ptable(next_index));
   return(ptable(next_index));
end;

decode_bit_string: procedure(bits);
   declare bits bit(*);
   declare child_index fixed binary(1);
   declare i fixed binary(24);
   declare pnode pointer initial(pnode_ro);
   declare this_used fixed binary(24) initial(0);
   do i = 1 to length(bits);
      child_index = convert(child_index, substr(bits, i, 1));
      pnode = pnode->children(child_index);
      if pnode->has_value then do;
         written = written + 1;
         substr(output, written, 1) = pnode->value;
         pnode = tree;
         this_used = i;
      end;
   end;
   pnode_ro = pnode;
   left = length(bits) - this_used;
   call adjust_prefix_length(this_used = 0);
end;

adjust_prefix_length: procedure(none_used);
   declare none_used bit;
   if none_used
      then prefix_length = prefix_length + left;
      else prefix_length = left;
end;

free_tree: procedure(tree) recursive;
   declare tree pointer;
   declare i fixed binary(2);
   declare garbage pointer;
   if tree = null
      then return;
   if ^tree->has_value then do;
      do i = lbound(tree->children, 1) to hbound(tree->children, 1);
         call free_tree(tree->children(i));
      end;
   end;
   garbage = tree;
   call noquit(operation);
 operation: procedure;
     tree = null;
     free garbage->node;
   end;
end;

free_tables: procedure;
   declare garbage pointer;
   declare i fixed binary(7);
   do i = lbound(ptable, 1) to hbound(ptable, 1);
      if ptable(i) ^= null then do;
         garbage = ptable(i);
         call noquit(operation);
      end;
   end;
operation: procedure;
      ptable(i) = null;
      free garbage->table;
   end;
end;

noquit: procedure(operation);
   declare operation entry;
   declare quit_pending bit initial("0"b);
   on quit begin;
      quit_pending = "1"b;
   end;
   call operation;
   revert quit;
   if quit_pending
      then signal quit;
end;

end decode_;
