/* -*- indent-tabs-mode: nil -*- */
decode_: procedure(source_arg, source_bitcount, destination_arg, order, codes,
                   used)
           returns(fixed binary(20));

declare source_arg pointer;
declare source_bitcount fixed binary(24);
declare destination_arg pointer;
declare order(0:511) fixed binary(9);
declare codes(0:511) bit(20) varying;
declare used fixed binary(24);

declare 01 node based,
           02 has_value bit aligned,
           02 value bit(9) aligned,
           02 children(0:1) pointer aligned;

declare 01 table(0:511) based aligned,
           02 num_bytes fixed binary(6),
           02 prefix_length fixed binary(5),
           02 next_pointer pointer,
           02 subtree pointer initial((512) null),
           02 byte(9) bit(9) unaligned;

declare 01 entry like table based aligned;

declare child_index fixed binary(1);
declare cleanup condition;
declare code_pointer pointer;
declare copy_destination(copy_length) bit(9) based(copy_destination_pointer);
declare copy_destination_pointer pointer;
declare copy_length fixed bin;
declare copy_source(copy_length) bit(9) based(copy_source_pointer);
declare copy_source_pointer pointer;
declare compress_bad_code condition;
declare destination pointer initial(destination_arg);
declare error condition;
declare i fixed binary(10);
declare input(divide(source_bitcount + 8, 9, 20)) bit(9) based(source);
declare j fixed binary(24);
declare left fixed binary(4);
declare null builtin;
declare old_written fixed binary(20);
declare output(255*1024*4) bit(9) based(destination);
declare partial_index fixed binary(24);
declare pentry pointer;
declare pnode pointer based(ppnode);
declare pnode_ro pointer;
declare ppnode pointer;
declare prefix_length fixed binary(24) initial(0);
declare ptable(31) pointer initial((31) null);
declare quit condition;
declare source pointer initial(source_arg);
declare subcode bit(20) varying;
declare table_index fixed binary(9);
declare tree pointer initial(null);
declare written fixed binary(20) initial(0);

if source_bitcount = used
   then return(written);

on cleanup begin;
   call free_tree(tree);
   call free_tables;
end;

do i = lbound(order, 1) to hbound(order, 1)
     while(length(codes(order(i))) > 0);
   subcode = codes(order(i));
   do ppnode = addr(tree) repeat addr(pnode->children(child_index))
        while(length(subcode) > 0);
      if pnode = null then do;
         allocate node set(pnode);
         pnode->has_value = "0"b;
         pnode->children = null;
      end;
      child_index = convert(child_index, substr(subcode, 1, 1));
      subcode = substr(subcode, 2);
   end;
   if pnode ^= null
      then signal error;
   allocate node set(pnode);
   pnode->has_value = "1"b;
   pnode->value = convert(pnode->value, order(i));
end;

pnode_ro = tree;
j = divide(used, 9, 24) + 1;
partial_index = hbound(input, 1);
if mod(source_bitcount, 9) = 0
   then partial_index = partial_index + 1;
call decode_bit_string(substr(input(j), mod(used, 9) + 1));
code_pointer = get_next_pointer(input(j));
do j = j + 1 to partial_index - 1;
  if code_pointer ^= null then do;
     table_index = convert(table_index, input(j));
     pentry = addr(code_pointer->table(table_index));
     if pentry->entry.subtree ^= null then do;
        copy_destination_pointer = addr(output(written + 1));
        copy_source_pointer = addr(pentry->entry.byte(1));
        copy_length = pentry->entry.num_bytes;
        do i = 1 to copy_length;
           copy_destination(i) = copy_source(i);
        end;
        written = written + copy_length;
        prefix_length = pentry->entry.prefix_length;
        pnode_ro = pentry->entry.subtree;
        code_pointer = pentry->entry.next_pointer;
     end;
     else do;
        old_written = written;
        call decode_bit_string(input(j));
        code_pointer = get_next_pointer(input(j));
        pentry->entry.num_bytes = written - old_written;
        do i = 1 to written - old_written;
           pentry->entry.byte(i) = output(old_written + i);
        end;
        pentry->entry.prefix_length = prefix_length;
        pentry->entry.next_pointer = code_pointer;
        pentry->entry.subtree = pnode_ro;
     end;
  end;
  else do;
     call decode_bit_string(input(j));
     code_pointer = get_next_pointer(input(j));
  end;
end;
if mod(source_bitcount, 9) ^= 0
   then call decode_bit_string(substr(input(partial_index), 1,
                                      mod(source_bitcount, 9)));
if prefix_length ^= 0 then do;
   used = source_bitcount - prefix_length;
   signal compress_bad_code;
end;

finish:
call free_tree(tree);
call free_tables;
return(written);

get_next_pointer: procedure(byte) returns(pointer);
   declare byte bit(9);
   declare next_index fixed binary(5);
   if left > 4
      then return(null);
   next_index =
     convert(next_index, "1"b || substr(byte, 10 - left, left));
   if ptable(next_index) = null
      then allocate table set(ptable(next_index));
   return(ptable(next_index));
end;

decode_bit_string: procedure(bits);
   declare bits bit(*);
   declare child_index fixed binary(1);
   declare i fixed binary(24);
   declare pnode pointer initial(pnode_ro);
   declare this_used fixed binary(24) initial(0);
   do i = 1 to length(bits);
      child_index = convert(child_index, substr(bits, i, 1));
      pnode = pnode->children(child_index);
      if pnode->has_value then do;
         written = written + 1;
         output(written) = pnode->value;
         pnode = tree;
         this_used = i;
      end;
   end;
   pnode_ro = pnode;
   left = length(bits) - this_used;
   call adjust_prefix_length(this_used = 0);
end;

adjust_prefix_length: procedure(any_used);
   declare any_used bit;
   if any_used
      then prefix_length = prefix_length + left;
      else prefix_length = left;
end;

free_tree: procedure(tree) recursive;
   declare tree pointer;
   declare i fixed binary(2);
   declare garbage pointer;
   if tree = null
      then return;
   if ^tree->has_value then do;
      do i = lbound(tree->children, 1) to hbound(tree->children, 1);
         call free_tree(tree->children(i));
      end;
   end;
   garbage = tree;
   call noquit(operation);
 operation: procedure;
     tree = null;
     free garbage->node;
   end;
end;

free_tables: procedure;
   declare garbage pointer;
   declare i fixed binary(6);
   do i = lbound(ptable, 1) to hbound(ptable, 1);
      if ptable(i) ^= null then do;
         garbage = ptable(i);
         call noquit(operation);
      end;
   end;
operation: procedure;
      ptable(i) = null;
      free garbage->table;
   end;
end;

noquit: procedure(operation);
   declare operation entry;
   declare quit_pending bit initial("0"b);
   on quit begin;
      quit_pending = "1"b;
   end;
   call operation;
   revert quit;
   if quit_pending
      then signal quit;
end;

end decode_;
