read_header_: procedure(bits, order, codes, padding_size)
  returns(fixed binary(24));

declare bits bit(*);
declare order(0:511) fixed binary(9);
declare codes(0:511) bit(20) varying;
declare padding_size fixed binary;

declare code_count fixed binary(10);
declare code_length fixed binary;
declare code_value fixed binary(21);
declare i fixed binary(10);
declare next_code bit(21) varying initial("0"b);
declare used fixed binary(24) initial(0);

codes = ""b;
order(0) = read_fixed(9);

do i = 1 to hbound(order, 1);
   order(i) = read_fixed(9);
   /* Recognize empty list, which is indicated by a repeated second element.
      If the list is in fact empty, set i to make it seem like we didn't read
      any elements.  As a useful side-effect, this will cause the next statement
      to recognize that the list terminator has been found. */
   if i > 1 & order(i) = order(1)
      then i = 0;
   /* Recognize terminator, which is indicated by a repeated first element. */
   if order(i) = order(0)
      then goto set_count;
end;

set_count:
code_count = i;

do i = 0 to code_count - 1;
   code_length = read_fixed(5);
   next_code = next_code || copy("0"b, code_length - length(next_code));
   codes(order(i)) = next_code;
   code_value = convert(code_value, next_code);
   code_value = code_value + 1;
   next_code = substr(convert(next_code, code_value),
		      21 - length(next_code) + 1);
end;

do i = lbound(codes, 1) to hbound(codes, 1);
   if length(codes(i)) = 0 then do;
      order(code_count) = i;
      code_count = code_count + 1;
   end;
end;

padding_size = read_fixed(4);

return(used);

read: procedure(length) returns(bit(*));
   declare length fixed binary;
   used = used + length;
   return(substr(bits, used - length + 1, length));
end;

read_fixed: procedure(length) returns(fixed binary(35));
   declare length fixed binary;
   declare result fixed binary(35);
   result = convert(result, read(length));
   return(result);
end;

end read_header_;
